MySQL数据库-sql语句- 

创建 classes 表 （专门处理 班级）

 create table classes (
    id int ,
    name VARCHAR(100)
    );
注意 id 并没有设置 自增长  因为  classes 表内的id 字段  需要和  students 表内的 class_id 字段 对应，因此 插入数据时 注意id的赋值。


 插入数据  注意 字段的引号 和 值 字符串引号的 区别
 insert into classes(`id`,`name`) values (1,'一班');


    students 表内的 class_id 字段 和 classes内的id 是对应的
    如： students 表内的 class_id  为1  对应  classes内的id =1的数据
    如下: 联表查询 注意：前一个表的引号

// 联表查询
    1：笛卡尔查询 （ 慎重使用 此方式查询）
    基础语法 select * from 表名A,表名B;
    命令： select * from `students`,classes; 或  select * from students,classes;
    注意：(这种多表查询又称笛卡尔查询使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛
    卡尔查询将返回1亿条记录)

    解释说明：因为是两张表查询，并不知道怎么合，因此相当于 students 表 中 每一项数据 都会去 classes 表中去合查询，
             而当前 students 表中10条数，classes 表中有 3 条数 ，查询出来的 总数据量 也正好是30条；当然可以加上 where 过滤条件 进行查询;
    执行命令输出如下：
    +----+---------------+-------+--------+---------------------+----------+----+--------+
    | id | name          | score | gender | create_time         | class_id | id | name   |
    +----+---------------+-------+--------+---------------------+----------+----+--------+
    |  1 | admin         |   100 |      1 | 2023-09-04 16:00:55 |        1 |  3 | 三班   |
    |  1 | admin         |   100 |      1 | 2023-09-04 16:00:55 |        1 |  2 | 二班   |
    |  1 | admin         |   100 |      1 | 2023-09-04 16:00:55 |        1 |  1 | 一班   |
    |  2 | 小明          |    91 |      1 | 2023-09-04 16:01:50 |        2 |  3 | 三班   |
    |  2 | 小明          |    91 |      1 | 2023-09-04 16:01:50 |        2 |  2 | 二班   |
    |  2 | 小明          |    91 |      1 | 2023-09-04 16:01:50 |        2 |  1 | 一班   |
    |  3 | 小红          |    98 |      0 | 2023-09-04 16:02:10 |        1 |  3 | 三班   |
    |  3 | 小红          |    98 |      0 | 2023-09-04 16:02:10 |        1 |  2 | 二班   |
    |  3 | 小红          |    98 |      0 | 2023-09-04 16:02:10 |        1 |  1 | 一班   |
    |  4 | 小黄          |    81 |      0 | 2023-09-04 16:18:38 |        3 |  3 | 三班   |
    |  4 | 小黄          |    81 |      0 | 2023-09-04 16:18:38 |        3 |  2 | 二班   |
    |  4 | 小黄          |    81 |      0 | 2023-09-04 16:18:38 |        3 |  1 | 一班   |
    |  5 | 张三          |   100 |      1 | 2023-09-04 16:50:30 |        2 |  3 | 三班   |
    |  5 | 张三          |   100 |      1 | 2023-09-04 16:50:30 |        2 |  2 | 二班   |
    |  5 | 张三          |   100 |      1 | 2023-09-04 16:50:30 |        2 |  1 | 一班   |
    |  6 | 测试1         |    80 |      1 | 2023-09-04 16:51:25 |        2 |  3 | 三班   |
    |  6 | 测试1         |    80 |      1 | 2023-09-04 16:51:25 |        2 |  2 | 二班   |
    |  6 | 测试1         |    80 |      1 | 2023-09-04 16:51:25 |        2 |  1 | 一班   |
    |  7 | 测试3         |    80 |      1 | 2023-09-04 16:51:35 |        2 |  3 | 三班   |
    |  7 | 测试3         |    80 |      1 | 2023-09-04 16:51:35 |        2 |  2 | 二班   |
    |  7 | 测试3         |    80 |      1 | 2023-09-04 16:51:35 |        2 |  1 | 一班   |
    |  8 | 测试          |   100 |      1 | 2023-09-04 16:54:02 |        2 |  3 | 三班   |
    |  8 | 测试          |   100 |      1 | 2023-09-04 16:54:02 |        2 |  2 | 二班   |
    |  8 | 测试          |   100 |      1 | 2023-09-04 16:54:02 |        2 |  1 | 一班   |
    |  9 | a测试3ccc     |    80 |      1 | 2023-09-04 17:02:16 |        2 |  3 | 三班   |
    |  9 | a测试3ccc     |    80 |      1 | 2023-09-04 17:02:16 |        2 |  2 | 二班   |
    |  9 | a测试3ccc     |    80 |      1 | 2023-09-04 17:02:16 |        2 |  1 | 一班   |
    | 10 | 小测试3ccc    |    80 |      1 | 2023-09-04 17:31:01 |        2 |  3 | 三班   |
    | 10 | 小测试3ccc    |    80 |      1 | 2023-09-04 17:31:01 |        2 |  2 | 二班   |
    | 10 | 小测试3ccc    |    80 |      1 | 2023-09-04 17:31:01 |        2 |  1 | 一班   |
    +----+---------------+-------+--------+---------------------+----------+----+--------+

    2： 注意当前查询也是 笛卡尔查询 方式 并没有增加其他查询条件 只是    使用表名.列名这样的方式 来引用 列和设置别名，这样就避免了结果集的列名重复问题
    基础语法： select 表名A.列名 可设置别名,表名A.列名,表名A.列名,表名B.列名 别名,表名B.列名 from 表名A,表名B;
    命令：select students.id sid,students.name,students.gender,students.score,classes.id cid,classes.name cname from students,classes;
        +-----+---------------+--------+-------+-----+--------+
        | sid | name          | gender | score | cid | cname  |
        +-----+---------------+--------+-------+-----+--------+
        |   1 | admin         |      1 |   100 |   3 | 三班   |
        |   1 | admin         |      1 |   100 |   2 | 二班   |
        |   1 | admin         |      1 |   100 |   1 | 一班   |
        |   2 | 小明          |      1 |    91 |   3 | 三班   |
        |   2 | 小明          |      1 |    91 |   2 | 二班   |
        |   2 | 小明          |      1 |    91 |   1 | 一班   |
        |   3 | 小红          |      0 |    98 |   3 | 三班   |
        |   3 | 小红          |      0 |    98 |   2 | 二班   |
        |   3 | 小红          |      0 |    98 |   1 | 一班   |
        |   4 | 小黄          |      0 |    81 |   3 | 三班   |
        |   4 | 小黄          |      0 |    81 |   2 | 二班   |
        |   4 | 小黄          |      0 |    81 |   1 | 一班   |
        |   5 | 张三          |      1 |   100 |   3 | 三班   |
        |   5 | 张三          |      1 |   100 |   2 | 二班   |
        |   5 | 张三          |      1 |   100 |   1 | 一班   |
        |   6 | 测试1         |      1 |    80 |   3 | 三班   |
        |   6 | 测试1         |      1 |    80 |   2 | 二班   |
        |   6 | 测试1         |      1 |    80 |   1 | 一班   |
        |   7 | 测试3         |      1 |    80 |   3 | 三班   |
        |   7 | 测试3         |      1 |    80 |   2 | 二班   |
        |   7 | 测试3         |      1 |    80 |   1 | 一班   |
        |   8 | 测试          |      1 |   100 |   3 | 三班   |
        |   8 | 测试          |      1 |   100 |   2 | 二班   |
        |   8 | 测试          |      1 |   100 |   1 | 一班   |
        |   9 | a测试3ccc     |      1 |    80 |   3 | 三班   |
        |   9 | a测试3ccc     |      1 |    80 |   2 | 二班   |
        |   9 | a测试3ccc     |      1 |    80 |   1 | 一班   |
        |  10 | 小测试3ccc    |      1 |    80 |   3 | 三班   |
        |  10 | 小测试3ccc    |      1 |    80 |   2 | 二班   |
        |  10 | 小测试3ccc    |      1 |    80 |   1 | 一班   |
        +-----+---------------+--------+-------+-----+--------+


 联表查询  join 方式 介绍说明：
    连接查询对多个表进行 JOIN 运算，简单地说，就是先确定一个 主表  作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。

    3： 联表查询 inner join （内连接） 方式  -  推荐使用 （inner JOIN 使用频率最高 on 条件（就是表A和表B 中间的条件 如 >, < ,= 等等） ）

    inner join 方式 只能 查询出来 两个表 有关联性的的 数据 案例在 （ 3-5 ：联表查询的 inner join 方式 说明：可见 ）

    基础语法：  select * from 表名A inner join 表名B  on  条件;
    命令： select * from  students inner join  classes on students.class_id=classes.id;
    解释说明： inner join 就是和什么表 进行连接 on 条件（就是表1和表2 中间的条件 如 >, < ,= 等等）
    +----+---------------+-------+--------+---------------------+----------+----+--------+
    | id | name          | score | gender | create_time         | class_id | id | name   |
    +----+---------------+-------+--------+---------------------+----------+----+--------+
    |  1 | admin         |   100 |      1 | 2023-09-04 16:00:55 |        1 |  1 | 一班   |
    |  2 | 小明          |    91 |      1 | 2023-09-04 16:01:50 |        2 |  2 | 二班   |
    |  3 | 小红          |    98 |      0 | 2023-09-04 16:02:10 |        1 |  1 | 一班   |
    |  4 | 小黄          |    81 |      0 | 2023-09-04 16:18:38 |        3 |  3 | 三班   |
    |  5 | 张三          |   100 |      1 | 2023-09-04 16:50:30 |        2 |  2 | 二班   |
    |  6 | 测试1         |    80 |      1 | 2023-09-04 16:51:25 |        2 |  2 | 二班   |
    |  7 | 测试3         |    80 |      1 | 2023-09-04 16:51:35 |        2 |  2 | 二班   |
    |  8 | 测试          |   100 |      1 | 2023-09-04 16:54:02 |        2 |  2 | 二班   |
    |  9 | a测试3ccc     |    80 |      1 | 2023-09-04 17:02:16 |        2 |  2 | 二班   |
    | 10 | 小测试3ccc    |    80 |      1 | 2023-09-04 17:31:01 |        2 |  2 | 二班   |
    +----+---------------+-------+--------+---------------------+----------+----+--------+
     3-1： 联表查询 inner join 方式  组合  排序 查询
    基础语法：  select * from 表名A inner join 表名B  on  条件  ORDER BY 字段;
    命令：SELECT * FROM `students`  INNER JOIN classes ON students.class_id = classes.id ORDER BY class_id;
    解释说明： inner join 就是和什么表 进行连接 on 条件（就是表1和表2 中间的条件 如 >, < ,= 等等） ORDER BY  （从小到大）
    +----+---------------+-------+--------+---------------------+----------+----+--------+
    | id | name          | score | gender | create_time         | class_id | id | name   |
    +----+---------------+-------+--------+---------------------+----------+----+--------+
    |  1 | admin         |   100 |      1 | 2023-09-04 16:00:55 |        1 |  1 | 一班   |
    |  3 | 小红          |    98 |      0 | 2023-09-04 16:02:10 |        1 |  1 | 一班   |
    |  2 | 小明          |    91 |      1 | 2023-09-04 16:01:50 |        2 |  2 | 二班   |
    |  5 | 张三          |   100 |      1 | 2023-09-04 16:50:30 |        2 |  2 | 二班   |
    |  6 | 测试1         |    80 |      1 | 2023-09-04 16:51:25 |        2 |  2 | 二班   |
    |  7 | 测试3         |    80 |      1 | 2023-09-04 16:51:35 |        2 |  2 | 二班   |
    |  8 | 测试          |   100 |      1 | 2023-09-04 16:54:02 |        2 |  2 | 二班   |
    |  9 | a测试3ccc     |    80 |      1 | 2023-09-04 17:02:16 |        2 |  2 | 二班   |
    | 10 | 小测试3ccc    |    80 |      1 | 2023-09-04 17:31:01 |        2 |  2 | 二班   |
    |  4 | 小黄          |    81 |      0 | 2023-09-04 16:18:38 |        3 |  3 | 三班   |
    +----+---------------+-------+--------+---------------------+----------+----+--------+


    3-3：联表查询 inner join 方式  组合 显示指定字段  字段设置别名 及其 排序 查询
    基础语法：  select 表名A.列名 可设置别名,表名A.列名 ,表名B.列名 可设置别名  from 表名A  inner join 表名B  on  条件  ORDER BY 字段;
    命令： select students.id sid,students.name,students.score,students.gender,students.class_id,classes.id cid,classes.name cname from students  inner join classes  on  students.class_id = classes.id ORDER BY class_id;
    +-----+---------------+-------+--------+----------+-----+--------+
    | sid | name          | score | gender | class_id | cid | cname  |
    +-----+---------------+-------+--------+----------+-----+--------+
    |   1 | admin         |   100 |      1 |        1 |   1 | 一班   |
    |   3 | 小红          |    98 |      0 |        1 |   1 | 一班   |
    |   2 | 小明          |    91 |      1 |        2 |   2 | 二班   |
    |   5 | 张三          |   100 |      1 |        2 |   2 | 二班   |
    |   6 | 测试1         |    80 |      1 |        2 |   2 | 二班   |
    |   7 | 测试3         |    80 |      1 |        2 |   2 | 二班   |
    |   8 | 测试          |   100 |      1 |        2 |   2 | 二班   |
    |   9 | a测试3ccc     |    80 |      1 |        2 |   2 | 二班   |
    |  10 | 小测试3ccc    |    80 |      1 |        2 |   2 | 二班   |
    |   4 | 小黄          |    81 |      0 |        3 |   3 | 三班   |
    +-----+---------------+-------+--------+----------+-----+--------+

    
    3-4： 上面的3-3写法 太多了  优化一下   给 表也使用别名吧  联表查询的方式  组合 显示指定字段  字段设置别名 及其 排序 (多个字段 排序规则)

    基础语法：  select 别名A.列名 可设置别名,别名A.列名 ,别名B.列名 可设置别名  from 表名A 别名A inner join 表名B 别名B on  条件  ORDER BY 字段A , 字段B desc;
    命令： select s.id sid,s.name sname,s.score,s.gender,s.class_id,c.id cid,c.name cname from students s inner join classes c on s.class_id = c.id order by class_id , score desc;
    解释说明 ：ORDER BY 字段A（当前为 class_id 班级字段）  先 根据 字段A 从小到大排序 ，desc 从大到小排序  根据 字段B（当前为 score 分数字段）
    +-----+---------------+-------+--------+----------+-----+--------+
    | sid | sname          | score | gender | class_id | cid | cname  |
    +-----+---------------+-------+--------+----------+-----+--------+
    |   1 | admin         |   100 |      1 |        1 |   1 | 一班   |
    |   3 | 小红          |    98 |      0 |        1 |   1 | 一班   |
    |   5 | 张三          |   100 |      1 |        2 |   2 | 二班   |
    |   8 | 测试          |   100 |      1 |        2 |   2 | 二班   |
    |   2 | 小明          |    91 |      1 |        2 |   2 | 二班   |
    |   6 | 测试1         |    80 |      1 |        2 |   2 | 二班   |
    |   7 | 测试3         |    80 |      1 |        2 |   2 | 二班   |
    |   9 | a测试3ccc     |    80 |      1 |        2 |   2 | 二班   |
    |  10 | 小测试3ccc    |    80 |      1 |        2 |   2 | 二班   |
    |   4 | 小黄          |    81 |      0 |        3 |   3 | 三班   |
    +-----+---------------+-------+--------+----------+-----+--------+

3-5 ：联表查询的 inner join 方式 说明：

    如 ： students 和classes 两张表 联表查询 只能查询 出 这个两个 表 有 交际关联 （students的class_id字段 和 classes的 id 字段） 的地方 ，
    如果没有 关联 （交际）是 联表查询是查询 不出来数据的。 下方实例 可以说明

    比方说：
    students 表中 插入 一条 class_id：5 （班级为 5班） 的数据列， 
    执行命令：  insert into students(`name`,`class_id`,`score`,`gender`) values ('aaa',5,60,1);
    查询插入结果 可见  class_id=5 的数据已经存在，
    命令： select * from students;
    +----+---------------+-------+--------+---------------------+----------+
    | id | name          | score | gender | create_time         | class_id |
    +----+---------------+-------+--------+---------------------+----------+
    |  1 | admin         |   100 |      1 | 2023-09-04 16:00:55 |        1 |
    |  2 | 小明          |    91 |      1 | 2023-09-04 16:01:50 |        2 |
    |  3 | 小红          |    98 |      0 | 2023-09-04 16:02:10 |        1 |
    |  4 | 小黄          |    81 |      0 | 2023-09-04 16:18:38 |        3 |
    |  5 | 张三          |   100 |      1 | 2023-09-04 16:50:30 |        2 |
    |  6 | 测试1         |    80 |      1 | 2023-09-04 16:51:25 |        2 |
    |  7 | 测试3         |    80 |      1 | 2023-09-04 16:51:35 |        2 |
    |  8 | 测试          |   100 |      1 | 2023-09-04 16:54:02 |        2 |
    |  9 | a测试3ccc     |    80 |      1 | 2023-09-04 17:02:16 |        2 |
    | 10 | 小测试3ccc    |    80 |      1 | 2023-09-04 17:31:01 |        2 |
    | 12 | aaa           |    60 |      1 | 2023-09-06 15:08:33 |        5 |
    +----+---------------+-------+--------+---------------------+----------+

    而 classes 表中 是没有 班级id 为5的数据，此时查询出来的结果 是没有关于 class_id：5的任何数据，

    执行联表查询命令：select s.id sid,s.name sname,s.score,s.gender,s.class_id,c.id cid,c.name cname from students s inner join classes c on s.class_id = c.id order by class_id , score desc;
    查询结果 可见  没有任何关于  class_id=5 的数据
    +-----+---------------+-------+--------+----------+-----+--------+
    | sid | sname         | score | gender | class_id | cid | cname  |
    +-----+---------------+-------+--------+----------+-----+--------+
    |   1 | admin         |   100 |      1 |        1 |   1 | 一班   |
    |   3 | 小红          |    98 |      0 |        1 |   1 | 一班   |
    |   5 | 张三          |   100 |      1 |        2 |   2 | 二班   |
    |   8 | 测试          |   100 |      1 |        2 |   2 | 二班   |
    |   2 | 小明          |    91 |      1 |        2 |   2 | 二班   |
    |   6 | 测试1         |    80 |      1 |        2 |   2 | 二班   |
    |   7 | 测试3         |    80 |      1 |        2 |   2 | 二班   |
    |   9 | a测试3ccc     |    80 |      1 |        2 |   2 | 二班   |
    |  10 | 小测试3ccc    |    80 |      1 |        2 |   2 | 二班   |
    |   4 | 小黄          |    81 |      0 |        3 |   3 | 三班   |
    +-----+---------------+-------+--------+----------+-----+--------+

    而 同样的 如  classes 表中 插入一条 id=4 （ 班级为 4班 ）的数据列，
    命令： insert into classes(`id`,`name`) values (4,'4班');
    查询插入结果 可见  id=4 的数据已经存在，
    命令： select * from classes;
        +----+--------+
        | id | name   |
        +----+--------+
        |  1 | 一班   |
        |  2 | 二班   |
        |  3 | 三班   |
        |  4 | 四班   |
        +----+--------+

    执行联表查询命令：select s.id sid,s.name sname,s.score,s.gender,s.class_id,c.id cid,c.name cname from students s inner join classes c on s.class_id = c.id order by class_id , score desc;
    查询结果 可见  没有任何关于  id=4 的数据
     +-----+---------------+-------+--------+----------+-----+--------+
    | sid | sname         | score | gender | class_id | cid | cname  |
    +-----+---------------+-------+--------+----------+-----+--------+
    |   1 | admin         |   100 |      1 |        1 |   1 | 一班   |
    |   3 | 小红          |    98 |      0 |        1 |   1 | 一班   |
    |   5 | 张三          |   100 |      1 |        2 |   2 | 二班   |
    |   8 | 测试          |   100 |      1 |        2 |   2 | 二班   |
    |   2 | 小明          |    91 |      1 |        2 |   2 | 二班   |
    |   6 | 测试1         |    80 |      1 |        2 |   2 | 二班   |
    |   7 | 测试3         |    80 |      1 |        2 |   2 | 二班   |
    |   9 | a测试3ccc     |    80 |      1 |        2 |   2 | 二班   |
    |  10 | 小测试3ccc    |    80 |      1 |        2 |   2 | 二班   |
    |   4 | 小黄          |    81 |      0 |        3 |   3 | 三班   |
    +-----+---------------+-------+--------+----------+-----+--------+


3-6 ：联表查询的 left join （ 左连接）方式 （以  left join 左侧的 表 为主）
    
    基础语法： select 别名A.列名 可设置别名,别名A.列名 ,别名B.列名 可设置别名  from 表名A 别名A left join 表名B 别名B on  条件  ORDER BY 字段A , 字段B desc;
    命令： select s.id sid,s.name sname,s.score,s.gender,s.class_id,c.id cid,c.name cname from students s left join classes c on s.class_id = c.id order by class_id , score desc;
    
    解释说明： 以 left join 左边的 表为主 完全查询输出 出左侧 表 内 存在 class_id 数据 ，如果 和右侧表 内的字段有关联性的 输出  至于和右侧表 没有关联会以 null 来补位
    如下控制台 输出结果： 
    可见 students 表 和classes 有关联性的 全部被查询 出来 ，
    而  students 表 和classes 没有关联性的 class_id=5的 字段 数据 也被查询 出来
    students 表内的 class_id=5的 字段 虽然没有在 classes表 查询到 有关联性的 id字段数据 但是以 null 来 补位
        +-----+---------------+-------+--------+----------+------+--------+
        | sid | sname         | score | gender | class_id | cid  | cname  |
        +-----+---------------+-------+--------+----------+------+--------+
        |   1 | admin         |   101 |      1 |        1 |    1 | 一班   |
        |   3 | 小红          |    99 |      0 |        1 |    1 | 一班   |
        |   5 | 张三          |   101 |      1 |        2 |    2 | 二班   |
        |   8 | 测试          |   101 |      1 |        2 |    2 | 二班   |
        |   2 | 小明          |    92 |      1 |        2 |    2 | 二班   |
        |   6 | 测试1         |    81 |      1 |        2 |    2 | 二班   |
        |   7 | 测试3         |    81 |      1 |        2 |    2 | 二班   |
        |   9 | a测试3ccc     |    81 |      1 |        2 |    2 | 二班   |
        |  10 | 小测试3ccc    |    81 |      1 |        2 |    2 | 二班   |
        |   4 | 小黄          |    82 |      0 |        3 |    3 | 三班   |
        |  12 | aaa           |    61 |      1 |        5 | NULL | NULL   |
        +-----+---------------+-------+--------+----------+------+--------+


3-7 ：联表查询的 right join （右连接）方式 （以  right join 右侧的 表 为主）
    基础语法： select 别名A.列名 可设置别名,别名A.列名 ,别名B.列名 可设置别名  from 表名A 别名A right join 表名B 别名B on  条件  ORDER BY 字段A , 字段B desc;
    命令： select s.id sid,s.name sname,s.score,s.gender,s.class_id,c.id cid,c.name cname from students s right join classes c on s.class_id = c.id order by class_id , score desc;
    解释说明： 以 right join 右侧的 表为主 完全查询输出 出右侧 表 内 存在 id 数据 ，如果 和左侧表内的字段有关联性的输出 ，至于 和左侧表没有关联性会以 null 来补位
    
    如下控制台 输出结果： 
    可见 classes  表 和  students 有关联性的 全部被查询 出来 ，
    而  classes 表 和 students 没有关联性的 id=4 的 字段 数据 也被查询 出来
    classes 表内的  id=4 的 字段 虽然没有在 students 表 查询到 有关联性的 class_id字段数据 但是以 null 来 补位
    +------+---------------+-------+--------+----------+-----+--------+
    | sid  | sname         | score | gender | class_id | cid | cname  |
    +------+---------------+-------+--------+----------+-----+--------+
    | NULL | NULL          |  NULL |   NULL |     NULL |   4 | 四班   |
    |    1 | admin         |   101 |      1 |        1 |   1 | 一班   |
    |    3 | 小红          |    99 |      0 |        1 |   1 | 一班   |
    |    8 | 测试          |   101 |      1 |        2 |   2 | 二班   |
    |    5 | 张三          |   101 |      1 |        2 |   2 | 二班   |
    |    2 | 小明          |    92 |      1 |        2 |   2 | 二班   |
    |   10 | 小测试3ccc    |    81 |      1 |        2 |   2 | 二班   |
    |    9 | a测试3ccc     |    81 |      1 |        2 |   2 | 二班   |
    |    7 | 测试3         |    81 |      1 |        2 |   2 | 二班   |
    |    6 | 测试1         |    81 |      1 |        2 |   2 | 二班   |
    |    4 | 小黄          |    82 |      0 |        3 |   3 | 三班   |
    +------+---------------+-------+--------+----------+-----+--------+



外键约束：
如 当前 students表中 插入了一条 class_id = 5 的数据，而且对应的 班级表 classes 中 并没有 id=5 班级为 5的数据，
那在前端发请求的时候 后端还得先查一下 classes 表 是否有 id=5 班级为 5的数据，如果不在 那就不能往 students表中插入存储数据，
或者 提交数据给后端时 恶意 提交了一些 没有关联 不能存的数据，而通过先查询  classes 表 来判断是否能 往 students表中插入存储数据，也比较麻烦，
后端  可以通过 （ 建立外键约束）  表与表之间的关联 来约束 这种情况 让这些 恶意的数据 或 来破坏的数据 无法插入 存储在数据表中 。
